package com.tyron.nanoj.core.indexing.spi;

import com.tyron.nanoj.api.vfs.FileObject;
import com.tyron.nanoj.core.indexing.IndexingStampStore;

import java.util.Map;

/**
 * Defines the logic for a specific type of index (e.g., Java Class Index, TODO Index).
 * <p>
 * This class is responsible for:
 * 1. Extracting data (Keys/Values) from a file.
 * 2. Serializing that data to bytes for the {@link com.tyron.nanoj.core.indexing.store.BucketedDiskStore}.
 * 3. Identifying which data belongs to which file for incremental updates.
 *
 * @param <K> Key type (e.g. String className, String methodSignature)
 * @param <V> Value type (e.g. ClassLocation, Integer offset). Must ensure it contains the FileID if strictly necessary for removal.
 */
public interface IndexDefinition<K, V> {

    /**
     * @return A unique identifier for this index (e.g., "java_classes", "xml_ids").
     * Used for folder naming and registry lookups.
     */
    String getId();

    /**
     * @return Version integer. Incrementing this should trigger a rebuild of this specific index.
     */
    int getVersion();

    /**
     * Returns true if this index should (re)index the given file.
     * <p>
     * Default implementation uses {@link IndexingStampStore} and checks the file's
     * {@code lastModified} + {@code length} stamp <b>per index ID</b>.
     * <p>
     * Index implementations may override this to:
     * <ul>
     *   <li>use stronger staleness signals (content hash, PSI version, etc.)</li>
     *   <li>force periodic rebuilds</li>
     *   <li>skip indexing for known-uninteresting files even if they changed</li>
     * </ul>
     */
    default boolean isOutdated(FileObject fileObject, IndexingStampStore stamps) {
        if (fileObject == null || stamps == null) {
            return true;
        }
        return !stamps.isUpToDate(getId(), getVersion(), fileObject);
    }

    /**
     * @return True if this indexer can process the given file type.
     */
    boolean supports(FileObject fileObject);

    /**
     * Parsing logic.
     *
     * @param file   The file to index.
     * @param helper Optional pre-calculated data (e.g., a Javac CompilationUnit) to avoid re-parsing.
     *               Can be null.
     * @return A map of extracted keys and their values.
     */
    Map<K, V> map(FileObject file, Object helper);

    /**
     * Convenience method if no helper is available.
     */
    default Map<K, V> map(FileObject file) {
        return map(file, null);
    }

    /**
     * Checks if a deserialized value belongs to the specified file.
     * <p>
     * <b>Crucial for Incremental Updates:</b>
     * When a file changes, the IndexManager retrieves all values associated with the keys
     * that file <i>used</i> to have. It iterates that list and calls this method.
     * If this returns true, the value is removed from the inverted index before new data is added.
     * </p>
     *
     * @param value  The value retrieved from the Inverted Index.
     * @param fileId The ID of the file currently being updated/removed.
     * @return true if this value instance was generated by the given fileId.
     */
    boolean isValueForFile(V value, int fileId);

    byte[] serializeKey(K key);

    byte[] serializeValue(V value);

    K deserializeKey(byte[] data);

    V deserializeValue(byte[] data);
}